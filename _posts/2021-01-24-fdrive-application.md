---
layout: post
author: "Piotr Strza≈Çka"
tags: [vesc, PROJECT f-drive, electronic, software-architecture]
---
# Fdrive application
{:.no_toc}
Some time ago I have started creating a e-bike conversion kit, based on friction drive principle. I found VESC to be suitable to act as a motor controller. Rest of the system is **[decribed in another post](/2021/01/31/fdrive-system-overview.html)**, check this out before going further in text. 
Component described in here is connected with **[Pedal Assist Sensor](/2020/11/07/vesc-custom-application-pas.html)**, (it uses signals from this component).
## Table of Contents
{:.no_toc}
* This will become a table of contents (this text will be scrapped).
{:toc}

# Architectural view

During my professional work I found diagrams very concise communication path. Even though this project is develop only by me in my spare time, creating a couple diagram speed up work and gives more joy of it. Placement of developed component in VESC system has been made in application level, which is highlighted in next picture.

{% include image.html url="/assets/uml/vesc-component-view.png" description="fdrive application placement in VESC structure" class="center" width="100%" %}

## Cooperation with components

Most significant paths of cooperations are shown on next diagram. I didn't want to show all of them to not darken the diagram.

{% include image.html url="/assets/uml/fdrive-components-cooperation.png" description="fdrive application placement in VESC structure" class="center"%}

- **app_pas_encoder** - provides information about crank movement
- **mcinterface** - is used to control motor 
- **mcpwm_foc** - also serves for motor control, but it is more low level
- **commands** - takes care about communication with user by command line
- **terminal** - used for registering callbacks from user input
- **conf_general** - gives access to flash emulated non-volatile memory
- **ch** - provides ChibiOS features
- **chevents** - also provides ChibiOS features but specifically in events scope 

## Main f-drive state machine

To handle problem of attaching, missattachment, cooperation with potentiometer, arming, disarming and other functions proper state machine is needed. Below is my current variation on this problem

{% include image.html url="/assets/uml/fdrive-app-sm.png" description="fdrive main state machine" class="center" width="100%" %}


In general the motor can be used exclisively by adc (practically speaking handlebar throttle) or pedal assist sensor.

``` c
#define FDRIVE_APP_ADC_LOWER_THRESHOLD     0.080f
#define FDRIVE_APP_ADC_HIGHER_THRESHOLD    0.120f

switch(app_state)
{
    case FDRIVE_APP_ADC:
        ...

        if(adc < FDRIVE_APP_ADC_LOWER_THRESHOLD){
            app_state = FDRIVE_APP_PAS;
            break;
        }
        break;
    
    case FDRIVE_APP_PAS:
        ...

        if(adc > FDRIVE_APP_ADC_HIGHER_THRESHOLD){
            app_state = FDRIVE_APP_ADC;
        }
        break;

    default:
        break;
}
```


In **adc "mode"** steering is simple, motor is driven in way that throttle is tilted. Attaching of the motor is in duty of the user.

**Fdrive "mode"** is a little more complicated: there are two main states Drive_Armed and Drive_NotArmed switched by PAS TurnBack Signal. According to that short sound signal "bip" (or twice "bip" for disarm) is generated by motor coils to give user feedback about system state. 

Composite state Drive_Armed defines strategy of attaching motor to the tire, as not go to the details, only to say that app_pas_encoder component is continously polled about crank rotation state and if it is forward it tries to keep motor attached. Code for this implementation id too long to be cited here, **[full source can be found on my github.](https://github.com/strzaleczka/bldc/blob/friction_drive/applications/app_fdrive.c)**.

## Storage of configuration in non volatile memory

If you look closely on main state machine, you will see that there are couple of paramateres which are good candidates for calibration values (i.e. jump time, attemps limit). Having possibility to change them without re-flashing the uC makes testing much easier. 

Here VESC framework comes with help, within conf_general module are embedded functions to store are read custom configuration.

``` c
/**
 * Read custom variable from emulated EEPROM.
...
 */
bool conf_general_read_eeprom_var_custom(eeprom_var *v, int address);

/**
 * Store hw-specific variable to emulated EEPROM.
 ...
 */
bool conf_general_store_eeprom_var_hw(eeprom_var *v, int address);

```

Our job is to prepare some meaningful struct with configuration, here is my attempt:

``` c

typedef struct
{
    uint32_t attach_time_ms;
    uint32_t cool_down_time_ms;
    float attach_speed_final_per;
    float attach_current_thr;
    uint32_t attempt_count_limit;
    uint32_t speed_goal_kmh;
} app_fdrive_config_type;

#define APP_FDRIVE_CONFIG_LENGTH sizeof(app_fdrive_config_type) / sizeof(eeprom_var)
//todo check if it is really helpful
typedef union
{
    app_fdrive_config_type config_struct;
    eeprom_var config_table[APP_FDRIVE_CONFIG_LENGTH];
} config_union;

```

I have also created an union to force the compiler to align struct in same way, and I am using it to pass struct to save/ read function. I am still not sure if it helps somehow, little //todo will track me back here later.

# Closure

Application is not finished, I barely belive if it ever will be finished, there is always something that can be done different. Fortunately VESC has possibility to be updated through bluetooth so I can make changes even in closed device.


---
layout: post
author: "Piotr Strza≈Çka"
tags: [vesc, PROJECT f-drive, electronic, software-architecture]
---
# VESC - fdrive application
{:.no_toc}
Some time ago I have started creating a e-bike conversion kit, based on friction drive principle. I found VESC to be suitable to act as a motor controller. Rest of the system is [decribed in another post](/2021/01/31/fdrive-system-overview.html), check this out before going further in text. 
Component described in here is connected with **[Pedal Assist Sensor](/2020/11/07/vesc-custom-application-pas.html)**, (it uses signals from this component).
## Table of Contents
{:.no_toc}
* This will become a table of contents (this text will be scrapped).
{:toc}

# Architectural view

During my professional work I found diagrams very concise communication path. Even though this project is develop only by me in my spare time, creating a couple diagram speed up work and gives more joy of it. Placement of developed component in VESC system has been made in application level, which is highlighted in next picture.

{% include image.html url="/assets/uml/vesc-component-view.png" description="fdrive application placement in VESC structure" class="center"%}

## Cooperation with components

{% include image.html url="/assets/uml/fdrive-components-cooperation.png" description="fdrive application placement in VESC structure" class="center"%}
## Main f-drive state machine

To handle problem of attaching, missattachment, cooperation with potentiometer, arming, disarming and other functions proper state machine is needed. Below is my current variation on this problem

{% include image.html url="/assets/uml/fdrive-app-sm.png" description="fdrive main state machine" class="center"%}


In general the motor can be used exclisively by adc (practically speaking handlebar throttle) or pedal assist sensor.

``` c
#define FDRIVE_APP_ADC_LOWER_THRESHOLD     0.080f
#define FDRIVE_APP_ADC_HIGHER_THRESHOLD    0.120f

switch(app_state)
{
    case FDRIVE_APP_ADC:
        ...

        if(adc < FDRIVE_APP_ADC_LOWER_THRESHOLD){
            app_state = FDRIVE_APP_PAS;
            break;
        }
        break;
    
    case FDRIVE_APP_PAS:
        ...

        if(adc > FDRIVE_APP_ADC_HIGHER_THRESHOLD){
            app_state = FDRIVE_APP_ADC;
        }
        break;

    default:
        break;
}
```


In **adc "mode"** steering is simple, motor is driven in way that throttle is tilted.

**Fdrive "mode"** is a little more complicated: there are two main state Drive_Armed and Drive_NotArmed switched by PAS TurnBack Signal. According to that short sound signal "bip" (or twice "bip" for disarm) is generated by motor coils to give user feedback about system state. 

Composite state Drive_Armed defines strategy of attaching motor to the tire, as not go to the details, only to say that PAS component is continously polled about crank rotation state and if it is forward it tries to keep motor attached. Code for this implementation id too long to be cited here, [full source can be found on my github.](https://github.com/strzaleczka/bldc/blob/friction_drive/applications/app_fdrive.c).

## Storage of configuration in non volatile memory

# Final thoughts



